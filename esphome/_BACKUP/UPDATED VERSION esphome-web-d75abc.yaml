substitutions:
  name: "esphome-web-d75abc"
  friendly_name: "SCANNER01"

  # I2C-Pins Display
  display_i2c_sda: GPIO04
  display_i2c_scl: GPIO05

  # I2C-Address OLED Display
  ssd1306_i2c_address: "0x3C"

  # UART-Pins  Barcode-Scanner
  uart_tx_pin: GPIO15
  uart_rx_pin: GPIO13

  # Pin Buzzer/Beeper
  #beeper_pin: GPIO02
  beeper_pin: GPIO14

  # Pins Switches and leds
  button_left_pin: GPIO01
  button_right_pin: GPIO03
  led_left_pin: GPIO00
  led_right_pin: GPIO16

# ----------------------------------
# ----       CONFIG END         ----
# ----------------------------------

esphome:
  name: "${name}"
  name_add_mac_suffix: false
  min_version: 2024.11.0
  project:
    name: scanner.vanhemert
    version: "0.2"
  on_boot: 
    - text_sensor.template.publish: # On boot set the status to connecting
        id: screen_mode
        state: "connecting"

esp8266:
  board: esp01_1m

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
      key: "Qa/VgI8wP3/db8OyRfHxY2eK7wdQ5ysB/sjzI2WShJE="
  actions:
    # When an identified product is passed back from HA
    - action: product_identified
      variables:
        product: string
      then:
        - text_sensor.template.publish: # Set the mode to result
            id: screen_mode
            state: "result"
        - text_sensor.template.publish: # Set the last result to the returned value
            id: last_result
            state: !lambda 'return product.c_str();'
        - script.execute: standby_timer # Start the timer to return to standby
        - logger.log: # Log the returned result
            level: INFO
            format: "Returned Product: %s"
            args: [ 'product.c_str()' ] 
  on_client_connected: # On successful connection to HA then set the status to standby
    - text_sensor.template.publish:
        id: screen_mode
        state: "standby"
    - script.stop: standby_timer # Stop the timer in case its running
  on_client_disconnected: # If the connection to HA is lost then set the status to connecting
    - text_sensor.template.publish: 
        id: screen_mode
        state: "connecting"
    - script.stop: standby_timer # Stop the timer in case its running

# Allow Over-The-Air updates
ota:
- platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

captive_portal:

improv_serial:

#######################################################################################################    
# CONFIG THE DEVICE
#######################################################################################################

# I2C
i2c:
  sda: "${display_i2c_sda}"
  scl: "${display_i2c_scl}"
  scan: false
  frequency: 400kHz
  id: i2c_bus

# Font
font:
  # Main text font
  - file: "gfonts://Space+Mono"
    id: space_mono
    size: 20
  # Material Design Icons
  - file: "gfonts://Material+Symbols+Outlined"
    id: icons_32
    size: 32
    glyphs: [
      "\U0000e70b", # mdi:barcode
      "\U0000e70c"  # mdi:barcode-scanner
      ] 

# Display
display:
  - platform: ssd1306_i2c
    id: "screen"
    model: "SSD1306 128x32"
    update_interval: 500ms
    rotation: 180
    lambda: |-
      if(id(screen_mode).state == "connecting") {
        it.print(0, 4, id(space_mono), "Connecting");
      } 
      else if(id(screen_mode).state == "standby") {
        it.print(0, 0, id(icons_32), "\U0000e70b");
        it.print(40, 4, id(space_mono), "Scan");
      } 
      else if(id(screen_mode).state == "scanned") {
        it.print(0, 4, id(space_mono), "Searching");
      } 
      else if(id(screen_mode).state == "result") {
        it.print(0, 4, id(space_mono), id(last_result).state.c_str());
      }
      else {
        it.print(0, 4, id(space_mono), "Unknow Error");
      }

# Scripts
script:
  # 30 second timer used to reset the screen back to standby
  - id: standby_timer 
    mode: restart
    then:
      - delay: 30s
      - text_sensor.template.publish:
          id: screen_mode
          state: "standby"

# Text Sensor
text_sensor:
  # Current status of the device. Used for what to show on the screen and not exposed to HA
  - platform: template
    id: screen_mode
    name: Screen Mode
    internal: true
  # Provided for diagnostic purposes only. You should use the HA event "esphome.barcode_scan" triggered when a scan is performed
  - platform: template
    id: last_barcode
    name: Last Barcode
    icon: mdi:barcode
    entity_category: DIAGNOSTIC
    disabled_by_default: true
  # Contains the last product passed back from HA. Used to display the result on the screen. Not exposed back to HA.
  - platform: template
    id: last_result
    name: Last Result
    internal: true

switch:
  - platform: gpio
    name: "Buzzer"
    inverted: false
    pin: "${beeper_pin}"
    id: beeper

# SCANNER
uart:
  # UART for the GM67 barcode scanner
  - id: scanner
    baud_rate: 9600
    tx_pin: ${uart_tx_pin}
    rx_pin: ${uart_rx_pin}
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: "\n"
      sequence:
        - if: # If a 13 or 8 digit numeric barcode was scanned
            condition:
              lambda: |-
                std::string str(bytes.begin(), bytes.end()); 
                if ( 
                  (strlen(str.c_str()) == 14 and str.substr(0, 13).find_first_not_of("0123456789") == std::string::npos) or // is 13 digit EAN-13 barcode
                  (strlen(str.c_str()) == 13 and str.substr(0, 12).find_first_not_of("0123456789") == std::string::npos) or // is 12 digit UPC-A barcode
                  (strlen(str.c_str()) == 9 and str.substr(0, 8).find_first_not_of("0123456789") == std::string::npos) // is 8 digit EAN-8 or UPC-E barcode
                ) { 
                  return true; 
                } else {
                  return false;
                } 
            then:
              # Log the received barcode and update the last_barcode and last_scan entities
              - lambda: |-
                  UARTDebug::log_string(direction, bytes);
                  std::string str(bytes.begin(), bytes.end());
                  id(last_barcode).publish_state(str.c_str()); 
                  id(last_scan).trigger("barcode_scanned"); 
              # Send a HA event with the scanned product barcode
              - homeassistant.event:
                  event: esphome.barcode_scan
                  data_template: 
                    barcode: "{{ scanned_barcode }}"
                  variables:
                    scanned_barcode: !lambda |-
                        std::string str(bytes.begin(), bytes.end()); 
                        return str.c_str(); 
              # Set the status to scanned
              - text_sensor.template.publish: 
                  id: screen_mode
                  state: "scanned"
              # Beep shortly when scanned
              - switch.turn_on: beeper
              - delay: 50ms
              - switch.turn_off: beeper
              # Start the timer to return to standby just in case nothing comes back from HA
              - script.execute: standby_timer 
        - if: # If a special QR code was scanned which contains text starting "GENERIC:"
            condition:
              lambda: |-
                std::string str(bytes.begin(), bytes.end());
                if (str.substr(0, 8) == "GENERIC:") { // starts with "GENERIC:"
                  return true; 
                } else {
                  return false;
                } 
            then:
              # Log the received barcode and update the last_barcode and last_scan entities
              - lambda: |-
                  UARTDebug::log_string(direction, bytes);
                  std::string str(bytes.begin(), bytes.end());
                  id(last_barcode).publish_state(str.substr(8).c_str()); // Get rid of the "GENERIC:" from the front
                  id(last_scan).trigger("barcode_scanned"); 
              # Send a HA event with the scanned product barcode
              - homeassistant.event:
                  event: esphome.generic_barcode_scan
                  data_template: 
                    product: "{{ scanned_product }}"
                  variables:
                    scanned_product: !lambda |-
                        std::string str(bytes.begin(), bytes.end()); 
                        return str.substr(8).c_str(); 
              # Set the status to scanned
              - text_sensor.template.publish: 
                  id: screen_mode
                  state: "scanned"              
              # Beep shortly when scanned
              - switch.turn_on: beeper
              - delay: 50ms
              - switch.turn_off: beeper
              # Start the timer to return to standby just in case nothing comes back from HA
              - script.execute: standby_timer 

# Event
event:
  # Provided for diagnostic purposes only. You should use the HA event "esphome.barcode_scan" triggered when a scan is performed
  - platform: template
    name: "Last Scan"
    id: "last_scan"
    icon: mdi:barcode-scan
    entity_category: DIAGNOSTIC
    disabled_by_default: true
    event_types:
      - "barcode_scanned"
  
#Switches with LED's
binary_sensor:
  - platform: gpio
    name: "Right button"
    pin: "${button_right_pin}"
    filters:
      - invert
  - platform: gpio
    name: "Left button"
    pin: "${button_left_pin}"
    filters:
      - invert
  
output:
  - id: led_right
    platform: gpio
    pin: "${led_right_pin}"
    inverted: false
  - id: led_left
    platform: gpio
    pin: "${led_left_pin}"
    inverted: false

light:
  - platform: binary
    name: "Right LED "
    output: led_right
  - platform: binary
    name: "Left LED "
    output: led_left
  

