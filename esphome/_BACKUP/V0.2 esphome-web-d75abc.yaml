substitutions:
  name: "esphome-web-d75abc"
  friendly_name: "SCANNER01"

  # I2C-Pins Display
  display_i2c_sda: GPIO04
  display_i2c_scl: GPIO05

  # I2C-Address OLED Display
  ssd1306_i2c_address: "0x3C"

  # UART-Pins  Barcode-Scanner
  uart_tx_pin: GPIO15
  uart_rx_pin: GPIO13

  # Pin Buzzer/Beeper
  #beeper_pin: GPIO02
  beeper_pin: GPIO14

  # Pins Switches and leds
  button_left_pin: GPIO01
  button_right_pin: GPIO03
  led_left_pin: GPIO00
  led_right_pin: GPIO16

# ----------------------------------
# ----       CONFIG END         ----
# ----------------------------------

esphome:
  name: "${name}"
  name_add_mac_suffix: false
  min_version: 2024.11.0
  project:
    name: scanner.vanhemert
    version: "0.1"
  on_boot:
    then:
      - lambda: id(last_barcode).publish_state("Scan Barcode");

esp8266:
  board: esp01_1m

# Enable Home Assistant API
api:
  encryption:
      key: "Qa/VgI8wP3/db8OyRfHxY2eK7wdQ5ysB/sjzI2WShJE="
  actions:
    # For now, when a product is identified it just logs it to the debug stream but this can be adapted to write to product to a screen
    - action: product_identified
      variables:
        product: string
      then:
        - logger.log: 
            level: INFO
            format: "Returned Product: %s"
            args: [ 'product.c_str()' ] 
        - lambda: |
            id(product_title) = product.c_str();

# Allow Over-The-Air updates
ota:
- platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

improv_serial:

captive_portal:

# Enable logging
logger:
  hardware_uart: UART0


# OLED DISPLAY
font:
  - file: "_fonts/arial.ttf"
    id: arial_font_16
    size: 16
    glyphs:  >-
      ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüöïéè€@<>/

  - file: "_fonts/arial.ttf"
    id: arial_font_18
    size: 18
    glyphs:  >-
      ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüöïéè€@<>/

  - file: "_fonts/arial.ttf"
    id: arial_font
    size: 30
    glyphs:  >-
      ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüöïéè€@<>/
    
i2c:
  sda: "${display_i2c_sda}"
  scl: "${display_i2c_scl}"
  scan: false
  frequency: 400kHz
  id: i2c_bus

# Display SCROLLING
# Code suggestion from  https://community.home-assistant.io/t/scrolling-text-on-ssd1306-oled-screen/305433/11
globals:
   - id: scroll_x
     type: int
     restore_value: no
     initial_value: '0'
   - id: scroll_length
     type: int
     restore_value: no
     initial_value: '0'
   - id: product_title
     type: std::string
     restore_value: no
     max_restore_data_length: 24
     initial_value: '"Klaar om te scannen"'

interval:
  - interval: 30ms
    then:
      - lambda: |-
          if (id(scroll_x) < -(id(scroll_length))) {
            // Start at right side of clipping area
            id(scroll_x) = 127; 
          }
          else  {
            id(scroll_x) -= 2;            
          }
# END SCROLLING

#Display definition
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: "${ssd1306_i2c_address}"
#    update_interval: 250ms
    update_interval: 100ms
    rotation: 180
    lambda: |-
      std::string printout=id(product_title).c_str();
      int clength = printout.length();
      id(scroll_length) = clength * 15;
      it.print(id(scroll_x), 5, id(arial_font_18), id(last_barcode).state.c_str());
      // multiplication factor (in this case 10) to be determined with trial and error based on your font width
      it.print(id(scroll_x), 25, id(arial_font), printout.c_str());
      
      
      
# SCANNER
uart:
  # UART for the GM67 barcode scanner
  - id: scanner
    baud_rate: 9600
    tx_pin: ${uart_tx_pin}
    rx_pin: ${uart_rx_pin}
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: "\n"
      sequence:
        - if: # If a 13 or 8 digit numeric barcode was scanned
            condition:
              lambda: |-
                std::string str(bytes.begin(), bytes.end()); 
                if ( 
                  (strlen(str.c_str()) == 14 and str.substr(0, 13).find_first_not_of("0123456789") == std::string::npos) or // is 13 digit EAN-13 barcode
                  (strlen(str.c_str()) == 13 and str.substr(0, 12).find_first_not_of("0123456789") == std::string::npos) or // is 12 digit UPC-A barcode
                  (strlen(str.c_str()) == 9 and str.substr(0, 8).find_first_not_of("0123456789") == std::string::npos) // is 8 digit EAN-8 or UPC-E barcode
                ) { 
                  return true; 
                } else {
                  return false;
                } 
            then:
              # Log the received barcode and update the last_barcode and last_scan entities
              - lambda: |-
                  UARTDebug::log_string(direction, bytes);
                  std::string str(bytes.begin(), bytes.end());
                  id(last_barcode).publish_state(str.c_str()); 
                  id(last_scan).trigger("barcode_scanned"); 
              # Send a HA event with the scanned product barcode
              - homeassistant.event:
                  event: esphome.barcode_scan
                  data_template: 
                    barcode: "{{ scanned_barcode }}"
                  variables:
                    scanned_barcode: !lambda |-
                        std::string str(bytes.begin(), bytes.end()); 
                        return str.c_str(); 
              # Beep shortly when scanned
              - switch.turn_on: beeper
              - delay: 50ms
              - switch.turn_off: beeper
        - if: # If a special QR code was scanned which contains text starting "GENERIC:"
            condition:
              lambda: |-
                std::string str(bytes.begin(), bytes.end());
                if (str.substr(0, 8) == "GENERIC:") { // starts with "GENERIC:"
                  return true; 
                } else {
                  return false;
                } 
            then:
              # Log the received barcode and update the last_barcode and last_scan entities
              - lambda: |-
                  UARTDebug::log_string(direction, bytes);
                  std::string str(bytes.begin(), bytes.end());
                  id(last_barcode).publish_state(str.substr(8).c_str()); // Get rid of the "GENERIC:" from the front
                  id(last_scan).trigger("barcode_scanned"); 
              # Send a HA event with the scanned product barcode
              - homeassistant.event:
                  event: esphome.generic_barcode_scan
                  data_template: 
                    product: "{{ scanned_product }}"
                  variables:
                    scanned_product: !lambda |-
                        std::string str(bytes.begin(), bytes.end()); 
                        return str.substr(8).c_str(); 
              # Beep shortly when scanned
              - switch.turn_on: beeper
              - delay: 50ms
              - switch.turn_off: beeper

# Text Sensor
text_sensor:
  # # Provided for diagnostic purposes only. You should use the HA event "esphome.barcode_scan" triggered when a scan is performed
  - platform: template
    id: last_barcode
    name: Last Barcode
    icon: mdi:barcode
    entity_category: DIAGNOSTIC
    disabled_by_default: true

switch:
  - platform: gpio
    name: "Buzzer"
    inverted: false
    pin: "${beeper_pin}"
    id: beeper

#Switches with LED's
binary_sensor:
  - platform: gpio
    name: "Right button"
    pin: "${button_right_pin}"
    filters:
      - invert
  - platform: gpio
    name: "Left button"
    pin: "${button_left_pin}"
    filters:
      - invert
  
output:
  - id: led_right
    platform: gpio
    pin: "${led_right_pin}"
    inverted: false
  - id: led_left
    platform: gpio
    pin: "${led_left_pin}"
    inverted: false

light:
  - platform: binary
    name: "Right LED "
    output: led_right
  - platform: binary
    name: "Left LED "
    output: led_left
  

# Event
event:
  # Provided for diagnostic purposes only. You should use the HA event "esphome.barcode_scan" triggered when a scan is performed
  - platform: template
    name: "Last Scan"
    id: "last_scan"
    icon: mdi:barcode-scan
    entity_category: DIAGNOSTIC
    disabled_by_default: true
    event_types:
      - "barcode_scanned"
  