#######################################################################################################    
# ESP8266 and GM67 Barcode Scanner and Printer
#######################################################################################################
substitutions:
  name: scanner-01
  friendly_name: SCANNER-01

  # I2C-Pins Display
  display_i2c_sda: GPIO04
  display_i2c_scl: GPIO05

  # I2C-Address OLED Display
  ssd1306_i2c_address: "0x3C"

  # UART-Pins  Barcode-Scanner
  uart_rx_pin_scan: GPIO03            # Black wire
  uart_tx_pin_scan: GPIO01            # Yellow wire

  # UART-Pins  Printer
  uart_rx_pin_print: GPIO14            # Green wire
  uart_tx_pin_print: GPIO12            # Yellow wire

  # Pins Switches and leds
  led_left_pin: GPIO13
  led_right_pin: GPIO15
  button_left_pin: GPIO00
  button_right_pin: GPIO02

# ----------------------------------
# ----       CONFIG END         ----
# ----------------------------------  
esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: false
  min_version: 2024.11.0
  project:
    name: vanhemert.scanner01
    version: "1.05"
  on_boot:
    - text_sensor.template.publish: # On boot set the status to connecting
        id: screen_mode
        state: "connecting"

esp8266:
  board: esp01_1m

# Enable logging
logger:
  baud_rate: 0
  
# Enable Home Assistant API
api:
  encryption:
      key: "Qa/VgI8wP3/db8OyRfHxY2eK7wdQ5ysB/sjzI2WShJE="
      #key: "9Ab5b3kw01TmGtPm762Iw2e3wqfaSdx7qa31awDUm7Y="
  actions:
    
    # Published service to support printing
    - service: write
      variables:
        command: string
      then:
        - uart.write:                     # https://community.home-assistant.io/t/uart-send-text-from-helper/396803/7
            id: printer
            data: !lambda |-
              std::string str = command;
              std::vector<uint8_t> vec(str.begin(), str.end());
              return vec;  
    
    # For now, when a product is identified it just logs it to the debug stream but this can be adapted to write to product to a screen
    - action: product_identified
      variables:
        product: string
      then:
        - text_sensor.template.publish: # Set the mode to result
            id: screen_mode
            state: "result"
        - text_sensor.template.publish: # Set the last result to the returned value
            id: last_result
            state: !lambda 'return product.c_str();'     
        - script.execute: standby_timer # Start the timer to return to standby
        - logger.log: 
            level: INFO
            format: "Returned Product: %s"
            args: [ 'product.c_str()' ] 
        - lambda: |
            id(product_title) = product.c_str();

  on_client_connected: # On successful connection to HA then set the status to standby
    - text_sensor.template.publish:
        id: screen_mode
        state: "standby"
    - script.stop: standby_timer # Stop the timer in case its running
  on_client_disconnected: # If the connection to HA is lost then set the status to connecting
    - text_sensor.template.publish: 
        id: screen_mode
        state: "connecting"
    - script.stop: standby_timer # Stop the timer in case its running

# Allow Over-The-Air updates
ota:
- platform: esphome

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid2
  password: !secret wifi_password2
  #use_address: 192.168.1.65

#improv_serial:

captive_portal:

#######################################################################################################    
# CONFIG THE DEVICE
#######################################################################################################

# I2C bus for OLED display
i2c:
  sda: "${display_i2c_sda}"
  scl: "${display_i2c_scl}"
  scan: false
  frequency: 400kHz
  id: i2c_bus

# Font used by OLED display
font:
  - file: "_fonts/arial.ttf"
    id: arial_font_18
    size: 18
    glyphs:  >-
      ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüöïéè€@<>/
  - file: "_fonts/arial.ttf"
    id: arial_font_24
    size: 24
    glyphs:  >-
      ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüöïéè€@<>/
  - file: "_fonts/arial.ttf"
    id: arial_font
    size: 30
    glyphs:  >-
      ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüöïéè€@<>/

  # Material Design Icons  https://fonts.google.com/icons?selected=Material+Symbols+Outlined:search:FILL@0;wght@400;GRAD@0;opsz@24&icon.size=24&icon.color=%235f6368
  - file: "gfonts://Material+Symbols+Outlined"
    id: icons_32
    size: 32
    glyphs: [
      "\U0000e70b", # mdi:barcode
      "\U0000e70c", # mdi:barcode-scanner
      "\U0000f85c", # mdi:barcode-reader
      "\U0000e63e", # mdi:wifi
      "\U0000e8b6", # mdi:search
      "\U0000e8ac"  # mdi:power
      ] 

# OLED DISPLAY
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: "${ssd1306_i2c_address}"
    update_interval: 75ms  # Was 100
    rotation: 0
    lambda: |-
      if(id(screen_mode).state == "connecting") {
        it.print(0, 0, id(icons_32), "\U0000e63e");
        std::string printout="Connecting to Home Assistant";
        int clength = printout.length();
        id(scroll_length) = clength * 15;
        // multiplication factor (in this case 10) to be determined with trial and error based on your font width
        it.print(id(scroll_x), 30, id(arial_font_24), printout.c_str());
      } 
      else if(id(screen_mode).state == "standby") {
        it.print(0, 0, id(icons_32), "\U0000f85c");
        it.print(40, 5, id(arial_font_24), "Gereed");

        std::string printout="Scan een product";
        int clength = printout.length();
        id(scroll_length) = clength * 15;
        // multiplication factor (in this case 10) to be determined with trial and error based on your font width
        it.print(id(scroll_x), 30, id(arial_font_24), printout.c_str());
      } 
      else if(id(screen_mode).state == "scanned") {
        it.print(0, 0, id(icons_32), "\U0000e8b6");
        it.print(0, 30, id( arial_font_24), "Zoeken");
      } 
      else if(id(screen_mode).state == "scanoff") {
        it.print(0, 0, id(icons_32), "\U0000e8ac");
        it.print(40, 6, id( arial_font_24), "Uit");           

      std::string printout="van Hemert - Home Automation";
        int clength = printout.length();
        id(scroll_length) = clength * 15;
        // multiplication factor (in this case 10) to be determined with trial and error based on your font width
        it.print(id(scroll_x), 30, id(arial_font_24), printout.c_str());
      } 
      else if(id(screen_mode).state == "result") {
        std::string printout=id(last_result).state.c_str();
        int clength = printout.length();
        id(scroll_length) = clength * 15;
        it.print(id(scroll_x), 5, id(arial_font_18), id(last_barcode).state.c_str());
        // multiplication factor (in this case 10) to be determined with trial and error based on your font width
        it.print(id(scroll_x), 30, id(arial_font_24), printout.c_str());
      }
       else {
        it.print(0, 4, id(arial_font_18), "Unknown Error");
      }     

# Display SCROLLING
globals:          #Code suggestion from  https://community.home-assistant.io/t/scrolling-text-on-ssd1306-oled-screen/305433/11
   - id: scroll_x
     type: int
     restore_value: no
     initial_value: '0'
   - id: scroll_length
     type: int
     restore_value: no
     initial_value: '0'
   - id: product_title
     type: std::string
     restore_value: no
     max_restore_data_length: 24
     initial_value: '"Klaar om te scannen"'

# Advance text 
interval:
  - interval: 30ms  # was 30
    then:
      - lambda: |-
          if (id(scroll_x) < -(id(scroll_length))) {
            // Start at right side of clipping area
            id(scroll_x) = 127; 
          }
          else  {
            id(scroll_x) -= 2;            
          }
 
# Scripts
script:
  # 30 second timer used to reset the screen back to standby
  - id: standby_timer 
    mode: restart
    then:
      - delay: 30s
      - text_sensor.template.publish:
          id: screen_mode
          state: "standby"


# Buttons with build in LEDs
output:
  - id: led_right
    platform: gpio
    pin: "${led_right_pin}"
    inverted: false
  - id: led_left
    platform: gpio
    pin: "${led_left_pin}"
    inverted: false
  
light:
  - platform: binary
    name: "Right LED "
    output: led_right
  - platform: binary
    name: "Left LED "
    output: led_left

binary_sensor:
  - platform: gpio
    name: "Right button"
    pin: 
      number: "${button_right_pin}"
      inverted: true
      mode:
        input: true
        pullup: true
  - platform: gpio
    name: "Left button"
    pin: 
      number: "${button_left_pin}"
      inverted: true  
      mode:
        input: true
        pullup: true
    
# Text Sensor
text_sensor:
    # Current status of the device. Used for what to show on the screen and not exposed to HA
  - platform: template
    id: screen_mode
    name: Screen Mode
    internal: true
  # # Provided for diagnostic purposes only. You should use the HA event "esphome.barcode_scan" triggered when a scan is performed
  - platform: template
    id: last_barcode
    name: Last Barcode
    icon: mdi:barcode
    entity_category: DIAGNOSTIC
    disabled_by_default: true
  # Contains the last product passed back from HA. Used to display the result on the screen. Not exposed back to HA.
  - platform: template
    id: last_result
    name: Last Result
    internal: true

# UART
uart:
  # UART for the GM67 barcode scanner
  - id: scanner
    rx_pin: "${uart_rx_pin_scan}"
    tx_pin: "${uart_tx_pin_scan}"
    baud_rate: 9600
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: "\r"
      sequence:
        - if: # If a supported 14, 13, 12 or 8 digit numeric barcode was scanned
            condition:
              lambda: |-
                std::string str(bytes.begin(), bytes.end()); 
                if ( 
                  (strlen(str.c_str()) == 14 and str.substr(0, 13).find_first_not_of("0123456789") == std::string::npos) or // is 13 digit EAN-13 barcode
                  (strlen(str.c_str()) == 13 and str.substr(0, 12).find_first_not_of("0123456789") == std::string::npos) or // is 12 digit UPC-A barcode
                  (strlen(str.c_str()) == 9 and str.substr(0, 8).find_first_not_of("0123456789") == std::string::npos) or   // is 8 digit EAN-8 or UPC-E barcode
                  (strlen(str.c_str()) == 15 and str.substr(0, 14).find_first_not_of("0123456789") == std::string::npos)    // is 14 digit ITF-14 barcode
                ) { 
                  return true; 
                } else {
                  return false;
                } 
            then:
              # Log the received barcode and update the last_barcode and last_scan entities
              - lambda: |-
                  UARTDebug::log_string(direction, bytes);
                  std::string str(bytes.begin(), bytes.end());
                  id(last_barcode).publish_state(str.c_str()); 
                  id(last_scan).trigger("barcode_scanned"); 
                  id(screen_mode).publish_state("scanned");
              # Send a HA event with the scanned product barcode
              - homeassistant.event:
                  event: esphome.scanner01_scan
                  data_template: 
                    barcode: "{{ scanned_barcode }}"
                  variables:
                    scanned_barcode: !lambda |-
                        std::string str(bytes.begin(), bytes.end()); 
                        return str.c_str(); 
              # Set the status to scanned
              - text_sensor.template.publish: 
                  id: screen_mode
                  state: "scanned"
              # Start the timer to return to standby just in case nothing comes back from HA
              - script.execute: standby_timer 
        - if: # If a special QR code was scanned which contains text starting "GENERIC:"
            condition:
              lambda: |-
                std::string str(bytes.begin(), bytes.end());
                if (str.substr(0, 8) == "GENERIC:") { // starts with "GENERIC:"
                  return true; 
                } else {
                  return false;
                } 
            then:
              # Log the received barcode and update the last_barcode and last_scan entities
              - lambda: |-
                  UARTDebug::log_string(direction, bytes);
                  std::string str(bytes.begin(), bytes.end());
                  id(last_barcode).publish_state(str.substr(8).c_str()); // Get rid of the "GENERIC:" from the front
                  id(last_scan).trigger("barcode_scanned");
                  id(screen_mode).publish_state("scanned"); 
              # Send a HA event with the scanned product barcode
              - homeassistant.event:
                  event: esphome.scanner01_generic
                  data_template: 
                    product: "{{ scanned_product }}"
                  variables:
                    scanned_product: !lambda |-
                        std::string str(bytes.begin(), bytes.end()); 
                        return str.substr(8).c_str(); 
              # Set the status to scanned
              - text_sensor.template.publish: 
                  id: screen_mode
                  state: "scanned"
              # Start the timer to return to standby just in case nothing comes back from HA
              - script.execute: standby_timer 
  # UART for the Thermal Printer
  - id: printer
    rx_pin: "${uart_rx_pin_print}"
    tx_pin: "${uart_tx_pin_print}"
    baud_rate: 9600
    debug:
      direction: BOTH
      dummy_receiver: false
      after:
        delimiter: "\n"
      sequence:
        - lambda: UARTDebug::log_string(direction, bytes);

# Event
event:
  # Provided for diagnostic purposes only. You should use the HA event "esphome.barcode_scan" triggered when a scan is performed
  - platform: template
    name: "Last Scan"
    id: "last_scan"
    icon: mdi:barcode-scan
    entity_category: DIAGNOSTIC
    disabled_by_default: false
    event_types:
      - "barcode_scanned"

# Reset from Home Assistant
button:
  - platform: restart
    name: "Restart"
    entity_category: CONFIG

# Select
select:
  # The scanning trigger mode of the GM67
  - platform: template
    name: "Trigger Mode"
    id: scan_mode
    optimistic: true
    icon: mdi:auto-mode
    entity_category: CONFIG
    options:
      - Button Holding
      - Button Trigger
      - Continuous Scanning
      - Automatic Induction
      - Host
    initial_option: Automatic Induction
    restore_value: true
    on_value:
      - if:
          condition:
            lambda: 'if (x == "Button Holding") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8A, 0x00, 0xFE, 0x9D]
      - if:
          condition:
            lambda: 'if (x == "Button Trigger") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8A, 0x02, 0xFE, 0x9B]
      - if:
          condition:
            lambda: 'if (x == "Continuous Scanning") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8A, 0x04, 0xFE, 0x99]
      - if:
          condition:
            lambda: 'if (x == "Automatic Induction") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8A, 0x09, 0xFE, 0x94]
      - if:
          condition:
            lambda: 'if (x == "Host") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8A, 0x08, 0xFE, 0x95]
  # Buzzer Volume
  - platform: template
    name: "Buzzer Volume"
    id: buzzer_volume
    optimistic: true
    icon: mdi:volume-high
    entity_category: CONFIG
    options:
      - 'Off'
      - Low
      - Medium
      - High
    initial_option: Medium
    restore_value: true
    on_value:
      - if: # Off
          condition:
            lambda: 'if (x == "Off") { return true; } else { return false; }'
          then:
            - uart.write: # Turn off
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x38, 0x00, 0xFE, 0xEF]
      - if: # Low
          condition:
            lambda: 'if (x == "Low") { return true; } else { return false; }'
          then:
            - uart.write: # Turn on
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x38, 0x01, 0xFE, 0xEE] 
            - uart.write: # Set low
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8C, 0x02, 0xFE, 0x99]
      - if: # Medium
          condition:
            lambda: 'if (x == "Medium") { return true; } else { return false; }'
          then:
            - uart.write: # Turn on
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x38, 0x01, 0xFE, 0xE]
            - uart.write: # Set medium
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8C, 0x01, 0xFE, 0x9A]
      - if: # High
          condition:
            lambda: 'if (x == "High") { return true; } else { return false; }'
          then:
            - uart.write: # Turn on
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x38, 0x01, 0xFE, 0xE]
            - uart.write: # Set high
                id: scanner
                data: [0x07, 0xC6, 0x04, 0x08, 0x00, 0x8C, 0x00, 0xFE, 0x9B]
  # Scanning Light
  - platform: template
    name: "Scanning Light"
    id: scanning_light
    optimistic: true
    icon: mdi:lightbulb-on
    entity_category: CONFIG
    options:
      - On When Reading
      - Always On
      - Always Off
    initial_option: On When Reading
    restore_value: true
    on_value:
      - if: # On When Reading
          condition:
            lambda: 'if (x == "On When Reading") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0x02, 0x00, 0xFE, 0x32]
      - if: # Always On
          condition:
            lambda: 'if (x == "Always On") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0x02, 0x01, 0xFE, 0x31]
      - if: # Always Off
          condition:
            lambda: 'if (x == "Always Off") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0x02, 0x02, 0xFE, 0x30]
  # Collimation
  - platform: template
    name: "Collimation"
    id: collimation
    optimistic: true
    icon: mdi:line-scan
    entity_category: CONFIG
    options:
      - On When Reading
      - Always On
      - Always Off
    initial_option: On When Reading
    restore_value: true
    on_value:
      - if: # On When Reading
          condition:
            lambda: 'if (x == "On When Reading") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0x03, 0x00, 0xFE, 0x31]
      - if: # Always On
          condition:
            lambda: 'if (x == "Always On") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0x03, 0x01, 0xFE, 0x30]
      - if: # Always Off
          condition:
            lambda: 'if (x == "Always Off") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0x03, 0x02, 0xFE, 0x2F]
  # Same Code Delay
  - platform: template
    name: "Same Code Delay"
    id: same_code_delay
    optimistic: true
    icon: mdi:repeat-variant
    entity_category: CONFIG
    options:
      - 0.5s
      - 1s
      - 3s
      - 5s
      - 7s 
      - No Repeat
    initial_option: 3s
    restore_value: true
    on_value:
      - if: # 0.5s
          condition:
            lambda: 'if (x == "0.5s") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF3, 0x03, 0x05, 0xFE, 0x2B]
      - if: # 1s
          condition:
            lambda: 'if (x == "1s") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xC9, 0x01, 0xFD, 0x6A]
      - if: # 3s
          condition:
            lambda: 'if (x == "3s") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xC9, 0x03, 0xFD, 0x68]
      - if: # 5s
          condition:
            lambda: 'if (x == "5s") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xC9, 0x05, 0xFD, 0x66]
      - if: # 7s
          condition:
            lambda: 'if (x == "7s") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xC9, 0x07, 0xFD, 0x64]
      - if: # No Repeat
          condition:
            lambda: 'if (x == "No Repeat") { return true; } else { return false; }'
          then:
            - uart.write: 
                id: scanner
                data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xC9, 0x09, 0xFD, 0x62]

switch:  
  # Collimation Flashing
  - platform: template
    name: "Collimation Flashing"
    id: collimation_flashing
    optimistic: true
    icon: mdi:line-scan
    entity_category: CONFIG
    restore_mode : RESTORE_DEFAULT_ON 
    turn_on_action:
      - uart.write: 
          id: scanner
          data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xB8, 0x00, 0xFD, 0x7C]
    turn_off_action:
      - uart.write: 
          id: scanner
          data: [0x08, 0xC6, 0x04, 0x08, 0x00, 0xF2, 0xB8, 0x01, 0xFD, 0x7B]
  # Scanning Enabled
  - platform: template
    name: "Scanning Enabled"
    id: scanning_enable
    optimistic: true
    icon: mdi:barcode-off
    entity_category: CONFIG
    restore_mode : RESTORE_DEFAULT_ON 
    turn_on_action:
      - uart.write: 
          id: scanner
          data: [0x04, 0xE9, 0x04, 0x00, 0xFF, 0x0F]
      - text_sensor.template.publish:
          id: screen_mode
          state: "standby"
    turn_off_action:
      - uart.write: 
          id: scanner
          data: [0x04, 0xEA, 0x04, 0x00, 0xFF, 0x0E]
      - text_sensor.template.publish:
          id: screen_mode
          state: "scanoff"
      - script.stop: standby_timer # Stop the timer in case its running

#######################################################################################################


    